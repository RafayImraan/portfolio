var E=0,d=0,o,S,l=!1,u=(...e)=>e.map(s=>s(u)),U=e=>{let s=`wire|${E++}{${e.name}}`,i,t={[s](){if(t.state&4)throw new Error(`Loop ${t.name}`);return w(t),t.state|=4,N(t,()=>i=e(r)),t.tasks.forEach(n=>n(i)),t.run++,t.state&=~(4|1),i}}[s],r=(...n)=>n.map(a=>a(r));return r.$$=1,r.wire=t,o&&o.lower.add(t),t.upper=o,t.tasks=new Set,t.$wire=1,t.run=0,f(t),t},f=e=>{e.state=1,e.lower=new Set,e.sigRS=new Set,e.sigRP=new Set,e.sigIC=new Set},T=e=>{let s=new Set(e),i;s.forEach(t=>{for((t.cs||t.state&2)&&(s.delete(t),t.state|=1),i=t;i=i.upper;)if(s.has(i))return s.delete(t)}),s.forEach(t=>t())},w=e=>{e.lower.forEach(w),e.sigRS.forEach(s=>s.wires.delete(e)),e.sigIC.forEach(s=>s.wires.delete(e)),f(e)},_=e=>{e.lower.forEach(_),e.state|=2},g=e=>(e.lower.forEach(g),e.cs||(e.state&=~2),!!(e.state&1)),W=(e,s="")=>{let i,t,r=`signal|${d++}{${s}}`,n={[r](...a){if(r=!a.length){if(o){if(o.sigRS.has(n))throw new Error(`${o.name} mixes sig($) & sig()`);o.sigRP.add(n)}}else if(!(r=a[0]===u))if(r=a[0]&&a[0].$$&&a[0].wire){if(r.sigRP.has(n))throw new Error(`${r.name} mixes sig($) & sig()`);r.sigRS.add(n),n.wires.add(r),n.cw&&(n.cw.state&1&&n.cw(),n.cw.sigRS.forEach(c=>{r.sigIC.add(c),c.wires.add(r)}))}else{if(S){S.add(n),n.next=a[0];return}n.cw&&(n.cw.tasks.delete(t),w(n.cw),delete n.cw.cs,delete n.cw),i=a[0],i&&i.$wire&&(i.cs=n,i.state|=2,i.tasks.add(t=c=>i=c),n.cw=i),l||T(n.wires)}if(r)return n.cw&&n.cw.state&1&&n.cw(),i}}[r];return n.$signal=1,n.wires=new Set,n(e),n},R=e=>(Object.keys(e).forEach(s=>{e[s]=W(e[s],s),d--}),d++,e);R.anon=W;var k=e=>{let s=S;S=new Set;let i,t;try{t=e();let r=S;S=s;let n=new Set;l=!0,r.forEach(a=>{a(a.next),delete a.next,a.wires.forEach(c=>n.add(c))}),l=!1,T(n)}catch(r){i=r}if(S=s,i)throw i;return t},N=(e,s)=>{let i=o;o=e;let t;try{s()}catch(r){t=r}if(o=i,t)throw t};export{R as signal,k as transaction,u as v$,U as wire,N as wireAdopt,_ as wirePause,w as wireReset,g as wireResume};
//# sourceMappingURL=index.js.map
