{
  "version": 3,
  "sources": ["./index.ts"],
  "sourcesContent": ["// Haptic's reactive state engine\n\ntype Signal<T = unknown> = {\n  /** Read value */\n  (): T;\n  /** Write value; notifying wires */ // Ordered before ($):T for TS to work\n  (value: T): void;\n  /** Read value & subscribe */\n  ($: SubToken): T;\n  /** Wires subscribed to this signal */\n  wires: Set<Wire<X>>;\n  /** Transaction value; set and deleted on commit */\n  next?: T;\n  /** If this is a computed-signal, this is its wire */\n  cw?: Wire<T>;\n  /** To check \"if x is a signal\" */\n  $signal: 1;\n};\n\ntype Wire<T = unknown> = {\n  /** Run the wire */\n  (): T;\n  /** Signals read-subscribed last run */\n  sigRS: Set<Signal<X>>;\n  /** Signals read-passed last run */\n  sigRP: Set<Signal<X>>;\n  /** Signals inherited from computed-signals, for consistent two-way linking */\n  sigIC: Set<Signal<X>>;\n  /** Post-run tasks */\n  tasks: Set<(nextValue: T) => void>;\n  /** Wire that created this wire (parent of this child) */\n  upper: Wire<X> | undefined;\n  /** Wires created during this run (children of this parent) */\n  lower: Set<Wire<X>>;\n  /** FSM state 3-bit bitmask: [RUNNING][SKIP_RUN_QUEUE][NEEDS_RUN] */\n  state: WireState;\n  /** Run count */\n  run: number;\n  /** If part of a computed signal, this is its signal */\n  cs?: Signal<T>;\n  /** To check \"if x is a wire\" */\n  $wire: 1;\n};\n\ntype SubToken = {\n  /** Allow $(...signals) to return an array of read values */\n  <U extends Array<() => unknown>>(...args: U): {\n    [P in keyof U]: U[P] extends Signal<infer R> ? R : never\n  };\n  /** Wire to subscribe to */\n  wire: Wire<X>;\n  /** To check \"if x is a subscription token\" */\n  $$: 1;\n};\n\n/** 3 bits: [RUNNING][SKIP_RUN_QUEUE][NEEDS_RUN] */\ntype WireState = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\n\n/* eslint-disable no-multi-spaces */\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\ntype X = any;\ntype P<T> = Partial<T>;\n\nlet wireId = 0;\nlet signalId = 0;\n\n// Currently running wire\nlet activeWire: Wire<X> | undefined;\n// Signals written to during a transaction\nlet transactionSignals: Set<Signal<X>> | undefined;\nlet transactionCommit = false;\n\n// Symbol() doesn't gzip well. `[] as const` gzips best but isn't debuggable\n// without a lookup Map<> and other hacks.\ndeclare const S_RUNNING        = 0b100;\ndeclare const S_SKIP_RUN_QUEUE = 0b010;\ndeclare const S_NEEDS_RUN      = 0b001;\n\n/**\n * Void subcription token. Used when a function demands a token but you don't\n * want to consent to any signal subscriptions. */\n// @ts-ignore\nconst v$: SubToken = ((...signals) => signals.map((sig) => sig(v$)));\n\n// In signalBase() and createWire() `{ [id]() {} }[id]` preserves the function\n// name which is useful for debugging\n\n/**\n * Create a wire. Activate the wire by running it (function call). Any signals\n * that read-subscribed during the run will re-run the wire later when written\n * to. Wires can be run anytime manually. They're pausable and are resumed when\n * called; resuming will avoid a wire run if the wire is not stale. Wires are\n * named by their function's name and a counter. */\nconst createWire = <T>(fn: ($: SubToken) => T): Wire<T> => {\n  const id = `wire|${wireId++}{${fn.name}}`;\n  let saved: T;\n  // @ts-ignore Missing properties right now but they're set in _initWire()\n  const wire: Wire<T> = { [id]() {\n    if (wire.state & S_RUNNING) {\n      throw new Error(`Loop ${wire.name}`);\n    }\n    // Symmetrically remove all connections between signals and wires. This is\n    // called \"automatic memory management\" in Sinuous/S.js\n    wireReset(wire);\n    wire.state |= S_RUNNING;\n    wireAdopt(wire, () => saved = fn($));\n    wire.tasks.forEach((task) => task(saved));\n    wire.run++;\n    wire.state &= ~(S_RUNNING | S_NEEDS_RUN);\n    return saved;\n  } }[id];\n  // @ts-ignore\n  const $: SubToken = ((...sig) => sig.map((_sig) => _sig($)));\n  $.$$ = 1;\n  $.wire = wire;\n  if (activeWire) activeWire.lower.add(wire);\n  wire.upper = activeWire;\n  wire.tasks = new Set();\n  wire.$wire = 1;\n  wire.run = 0;\n  // Outside of _initWire because this persists across wire resets\n  _initWire(wire);\n  return wire;\n};\n\nconst _initWire = (wire: Wire<X>): void => {\n  wire.state = S_NEEDS_RUN;\n  wire.lower = new Set();\n  // Drop all signals now that they have been unlinked\n  wire.sigRS = new Set();\n  wire.sigRP = new Set();\n  wire.sigIC = new Set();\n};\n\nconst _runWires = (wires: Set<Wire<X>>): void => {\n  // Use a new Set() to avoid infinite loops caused by wires writing to signals\n  // during their run.\n  const toRun = new Set(wires);\n  let curr: Wire<X> | undefined;\n  // Mark upstream computeds as stale. Must be in an isolated for-loop\n  toRun.forEach((wire) => {\n    if (wire.cs || wire.state & S_SKIP_RUN_QUEUE) {\n      toRun.delete(wire);\n      wire.state |= S_NEEDS_RUN;\n    }\n    // TODO: Test (#3) + Benchmark with main branch\n    // If a wire's ancestor will run it'll destroy its lower wires. It's more\n    // efficient to not call them at all by deleting from the run list:\n    curr = wire;\n    while ((curr = curr.upper))\n      if (toRun.has(curr)) return toRun.delete(wire);\n  });\n  toRun.forEach((wire) => wire() as void);\n};\n\n/**\n * Removes two-way subscriptions between its signals and itself. This also turns\n * off the wire until it is manually re-run. */\nconst wireReset = (wire: Wire<X>): void => {\n  wire.lower.forEach(wireReset);\n  wire.sigRS.forEach((signal) => signal.wires.delete(wire));\n  wire.sigIC.forEach((signal) => signal.wires.delete(wire));\n  _initWire(wire);\n};\n\n/**\n * Pauses a wire so signal writes won't cause runs. Affects nested wires */\nconst wirePause = (wire: Wire<X>): void => {\n  wire.lower.forEach(wirePause);\n  wire.state |= S_SKIP_RUN_QUEUE;\n};\n\n/**\n * Resumes a paused wire. Affects nested wires but skips wires belonging to\n * computed-signals. Returns true if any runs were missed during the pause */\nconst wireResume = (wire: Wire<X>): boolean => {\n  wire.lower.forEach(wireResume);\n  // Clears SKIP_RUN_QUEUE only if it's NOT a computed-signal\n  if (!wire.cs) wire.state &= ~S_SKIP_RUN_QUEUE;\n  // eslint-disable-next-line no-implicit-coercion\n  return !!(wire.state & S_NEEDS_RUN);\n};\n\nconst signalBase = <T>(value: T, id = ''): Signal<T> => {\n  type W = Wire<X>;\n  let saved: unknown;\n  let cwTask: ((value: unknown) => void) | undefined;\n  // Multi-use temp variable\n  let read: unknown = `signal|${signalId++}{${id}}`;\n  const signal = { [read as string](...args: [$?: SubToken, ..._: unknown[]]) {\n    // Case: Read-Pass. Marks the active running wire as a reader\n    if ((read = !args.length)) {\n      if (activeWire) {\n        if (activeWire.sigRS.has(signal)) {\n          throw new Error(`${activeWire.name} mixes sig($) & sig()`);\n        }\n        activeWire.sigRP.add(signal);\n      }\n    }\n    // Case: Void token\n    else if ((read = args[0] === v$)) {}\n    // Case: Read-Subscribe. Marks the wire registered in `$` as a reader\n    // This could be different than the actively running wire, but shouldn't be\n    else if ((read = args[0] && (args[0] as P<SubToken>).$$ && args[0].wire)) {\n      if ((read as W).sigRP.has(signal)) {\n        throw new Error(`${(read as W).name} mixes sig($) & sig()`);\n      }\n      // Two-way link. Signal writes will now call/update wire W\n      (read as W).sigRS.add(signal);\n      signal.wires.add((read as W));\n\n      // Computed-signals can't only run W when written to, they also need to\n      // run W when signal.cw is marked stale. How do we know when that happens?\n      // It's when a cw.sigRS signal tries to call signal.cw. So adding `read`\n      // to each signal in cw.sigRS will call W as collateral.\n      if (signal.cw) {\n        // Run early if sigRS isn't ready (see \"Update if needed\" line below)\n        if (signal.cw.state & S_NEEDS_RUN) signal.cw();\n        signal.cw.sigRS.forEach((_signal) => {\n          // Linking _must_ be two-way. From signal.wires to wire.sigXYZ. Until\n          // now it's always either sigRS or sigRP, but if we use those we'll\n          // break the mix error checking (above). So use a new list, sigIC.\n          (read as W).sigIC.add(_signal);\n          _signal.wires.add((read as W));\n        });\n      }\n    }\n    // Case: Write\n    else {\n      // If in a transaction; defer saving the value\n      if (transactionSignals) {\n        transactionSignals.add(signal);\n        signal.next = args[0] as unknown as T;\n        return;\n      }\n      // If overwriting a computed-signal wire, unsubscribe the wire\n      if (signal.cw) {\n        signal.cw.tasks.delete(cwTask as () => void);\n        wireReset(signal.cw);\n        delete signal.cw.cs;\n        delete signal.cw;\n        // cwTask = undefined;\n      }\n      saved = args[0] as unknown as T;\n      // If writing a wire, this signal becomes as a computed-signal\n      if (saved && (saved as P<Wire>).$wire) {\n        (saved as W).cs = signal;\n        (saved as W).state |= S_SKIP_RUN_QUEUE;\n        (saved as W).tasks.add(cwTask = (value) => saved = value);\n        signal.cw = saved as W;\n        // saved = undefined;\n      }\n      // Notify every write _unless_ this is a post-transaction commit\n      if (!transactionCommit) _runWires(signal.wires);\n    }\n    if (read) {\n      // Update if needed\n      if (signal.cw && signal.cw.state & S_NEEDS_RUN) signal.cw();\n      return saved;\n    }\n  } }[read as string] as Signal<T>;\n  signal.$signal = 1;\n  signal.wires = new Set<Wire<X>>();\n  // Call it to run the \"Case: Write\" and de|initialize computed-signals\n  signal(value);\n  return signal;\n};\n\n/**\n * Creates signals for each object entry. Signals are read/write variables which\n * hold a list of subscribed wires. When a value is written those wires are\n * re-run. Writing a wire into a signal creates a lazy computed-signal. Signals\n * are named by the key of the object entry and a global counter. */\nconst createSignal = <T>(obj: T): {\n  [K in keyof T]: Signal<T[K] extends Wire<infer R> ? R : T[K]>;\n} => {\n  Object.keys(obj).forEach((k) => {\n    // @ts-ignore Mutation of T\n    obj[k] = signalBase(obj[k as keyof T], k);\n    signalId--;\n  });\n  signalId++;\n  // @ts-ignore Mutation of T\n  return obj;\n};\ncreateSignal.anon = signalBase;\n\n/**\n * Batch signal writes so only the last write per signal is applied. Values are\n * committed at the end of the function call. */\nconst transaction = <T>(fn: () => T): T => {\n  const prev = transactionSignals;\n  transactionSignals = new Set();\n  let error: unknown;\n  let ret: unknown;\n  try {\n    ret = fn();\n    const signals = transactionSignals;\n    transactionSignals = prev;\n    const transactionWires = new Set<Wire<X>>();\n    transactionCommit = true;\n    signals.forEach((signal) => {\n      // Doesn't run any subscribed wires since `transactionCommit` is set\n      signal(signal.next);\n      delete signal.next;\n      signal.wires.forEach((wire) => transactionWires.add(wire));\n    });\n    transactionCommit = false;\n    _runWires(transactionWires);\n  } catch (err) {\n    error = err;\n  }\n  // Yes this happens a few lines up; do it again in case the `try` throws\n  transactionSignals = prev;\n  if (error) throw error;\n  return ret as T;\n};\n\n/**\n * Run a function within the context of a wire. Wires created in this context\n * are adopted (see wire.lower). This affects signal read consistency checks for\n * read-pass (signal.sigRP) and read-subscribe (signal.sigRS). */\nconst wireAdopt = <T>(wire: Wire<X> | undefined, fn: () => T): void => {\n  const prev = activeWire;\n  activeWire = wire;\n  let error: unknown;\n  // Note: Can't use try+finally it swallows the error instead of throwing\n  try {\n    fn();\n  } catch (err) {\n    error = err;\n  }\n  activeWire = prev;\n  if (error) throw error;\n};\n\nexport {\n  // Using createX avoids variable shadowing, rename here\n  createSignal as signal,\n  createWire as wire,\n  wireReset,\n  wirePause,\n  wireResume,\n  wireAdopt,\n  transaction,\n  v$ // Actual subtokens are only ever provided by a wire\n};\n\nexport type { Signal, Wire, WireState, SubToken };\n"],
  "mappings": "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",
  "names": []
}
