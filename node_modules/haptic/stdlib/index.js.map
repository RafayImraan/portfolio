{
  "version": 3,
  "sources": ["./index.ts"],
  "sourcesContent": ["import { h } from 'haptic/dom';\nimport { signal, Signal, wire, wireAdopt, wirePause, wireResume } from 'haptic/state';\n\nimport type { Wire, SubToken } from 'haptic/state';\nimport type { El } from 'haptic/dom';\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\n/** Switches DOM content by creating a wire responds to a changing condition. */\nconst when = <T extends string>(\n  condition: ($: SubToken) => T,\n  views: { [k in T]?: () => El }\n): Wire<El | undefined> => {\n  type ActiveMeta = { elementRoot: El | undefined, wireRoot: Wire<void> };\n  const active = {} as { [k in T]?: ActiveMeta };\n  let condRendered: T;\n  return wire(($) => {\n    // Creates subscriptions to signals (hopefully)\n    const cond = condition($);\n    if (cond === condRendered) {\n      return active[condRendered]!.elementRoot;\n    }\n    condRendered = cond;\n    let a: ActiveMeta | undefined;\n    // Else, content is changing. Pause wires for the current element\n    if ((a = active[condRendered])) {\n      wirePause(a.wireRoot);\n    }\n    // Have we rendered this condition before?\n    if ((a = active[cond])) {\n      // Then unpause its wires and return its pre-rendered element\n      const stale = wireResume(a.wireRoot);\n      if (stale) a.wireRoot();\n      return a.elementRoot;\n    }\n    // Else, we need to render from scratch\n    wireAdopt(undefined, () => {\n      // The above line avoids the upper/lower relationship that's normally made\n      // when creating a wire in a wire. This root is isolated.\n      const wireRoot = wire(() => {});\n      wireAdopt(wireRoot, () => {\n        // All wires within views[cond] are adopted to wireRoot for pause/resume\n        a = active[cond] = { elementRoot: h(views[cond]!), wireRoot };\n      });\n    });\n    return a!.elementRoot;\n  });\n};\n\n/**\n * Returns a signal that only dispatches when the condition is different. This\n * internally uses a wire with `!==` for change comparison */\nconst signalFrom = <T>(cond: ($: SubToken) => T): Signal<T> => {\n  let s: Signal<T> | undefined;\n  wire(($) => {\n    const c = cond($);\n    if (!s) s = signal.anon<T>(c); // First run\n    else if (s() !== c) s(c);\n  })();\n  return s!;\n};\n\nexport { when, signalFrom };\n"],
  "mappings": "AAAA,+BACA,8FAQA,GAAM,GAAO,CACX,EACA,IACyB,CAEzB,GAAM,GAAS,GACX,EACJ,MAAO,GAAK,AAAC,GAAM,CAEjB,GAAM,GAAO,EAAU,GACvB,GAAI,IAAS,EACX,MAAO,GAAO,GAAe,YAE/B,EAAe,EACf,GAAI,GAMJ,MAJK,GAAI,EAAO,KACd,EAAU,EAAE,UAGT,GAAI,EAAO,IAGV,CADU,EAAW,EAAE,WAChB,EAAE,WACN,EAAE,aAGX,GAAU,OAAW,IAAM,CAGzB,GAAM,GAAW,EAAK,IAAM,IAC5B,EAAU,EAAU,IAAM,CAExB,EAAI,EAAO,GAAQ,CAAE,YAAa,EAAE,EAAM,IAAS,gBAGhD,EAAG,gBAOR,EAAa,AAAI,GAAwC,CAC7D,GAAI,GACJ,SAAK,AAAC,GAAM,CACV,GAAM,GAAI,EAAK,GACf,AAAK,EACI,MAAQ,GAAG,EAAE,GADd,EAAI,EAAO,KAAQ,OAGtB",
  "names": []
}
