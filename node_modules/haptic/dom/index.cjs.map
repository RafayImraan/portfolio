{
  "version": 3,
  "sources": ["../../src/dom/index.ts", "../../src/dom/h.ts", "../../src/dom/nodeAdd.ts", "../../src/dom/nodeInsert.ts", "../../src/dom/nodeProperty.ts", "../../src/dom/nodeRemove.ts", "../../src/dom/svg.ts"],
  "sourcesContent": ["import { h as _h } from './h.js';\n\nimport { add } from './nodeAdd.js';\nimport { insert } from './nodeInsert.js';\nimport { property } from './nodeProperty.js';\nimport { remove } from './nodeRemove.js';\n\nimport { svg } from './svg.js';\n\nimport type { Component, El, Tag } from './h.js';\n\n// This API should be compatible with community libraries that extend Sinuous\nconst api: {\n  /** Hyperscript reviver */\n  h: typeof _h;\n  // Customizable internal methods for h()\n  add: typeof add;\n  insert: typeof insert;\n  property: typeof property;\n  // Renamed for compatibility with Sinuous' community libraries\n  rm: typeof remove;\n  /** DOM patcher. Receives unknown JSX elements and attributes. To mark the DOM\n  location as reactive, return true. Call patchDOM() anytime to update. */\n  patch: (\n    value: unknown,\n    // Reactivity could be from Haptic, Sinuous, MobX, Hyperactiv, etc\n    patchDOM?: (value: unknown) => void,\n    // Element being patched\n    el?: Node,\n    // If this is patching an element property, this is the attribute\n    attribute?: string\n  ) => boolean,\n  /** Element namespace URL such as SVG or MathML */\n  ns?: string;\n} = {\n  h: _h,\n  add,\n  insert,\n  property,\n  rm: remove,\n  patch: () => false,\n};\n\n// Reference the latest internal h() allowing others to customize the call\nconst h: typeof _h = (...args) => api.h(...args);\n\nexport { api, h, svg };\nexport type { Component, El, Tag };\n", "import { api } from './index.js';\n\nimport type { GenericEventAttrs, HTMLAttrs, SVGAttrs, HTMLElements, SVGElements } from '../jsx';\n\ntype El = Element | Node | DocumentFragment;\ntype Tag = El | Component | [] | string;\ntype Component = (...args: unknown[]) => El | undefined;\n\nfunction h(tag: Tag, props?: unknown, ...children: unknown[]): El | undefined\nfunction h(tag: Tag, ...args: unknown[]): El | undefined {\n  if (typeof tag === 'function') {\n    return tag(...args);\n  }\n  let el: El, arg: unknown;\n  if (typeof tag === 'string') {\n    el = api.ns\n      ? document.createElementNS(api.ns, tag)\n      : document.createElement(tag);\n  }\n  else if (Array.isArray(tag)) {\n    el = document.createDocumentFragment();\n    // Using unshift(tag) is -1b gz smaller but is an extra loop iteration\n    args.unshift(...tag);\n  }\n  // Hopefully Element, Node, DocumentFragment, but could be anything...\n  else {\n    el = tag;\n  }\n  while (args.length) {\n    arg = args.shift();\n    // eslint-disable-next-line eqeqeq\n    if (arg == null) {}\n    else if (typeof arg === 'string' || arg instanceof Node) {\n      // Direct add fast path\n      api.add(el, arg);\n    }\n    else if (Array.isArray(arg)) {\n      args.unshift(...arg);\n    }\n    else if (typeof arg === 'object') {\n      // eslint-disable-next-line no-implicit-coercion\n      api.property(el, arg, null, !!api.ns);\n    }\n    else if (api.patch(arg)) {\n      // Last parameter, endMark, is a Text('') node; see nodeAdd.js#Frag\n      api.insert(el, arg, api.add(el, '') as Text);\n    }\n    else {\n      // Default case, cast as string and add\n      // eslint-disable-next-line no-implicit-coercion,@typescript-eslint/restrict-plus-operands\n      api.add(el, '' + arg);\n    }\n  }\n  return el;\n}\n\nexport { h };\nexport type { Component, El, Tag };\n\n// JSX namespace must be bound into a function() next to its definition\ndeclare namespace h {\n  export namespace JSX {\n    type Element = HTMLElement | SVGElement | DocumentFragment;\n\n    interface ElementAttributesProperty { props: unknown; }\n    interface ElementChildrenAttribute { children: unknown; }\n\n    // Prevent children on components that don't declare them\n    interface IntrinsicAttributes { children?: never; }\n\n    // Allow children on all DOM elements (not components, see above)\n    // ESLint will error for children on void elements like <img/>\n    type DOMAttributes<Target extends EventTarget>\n      = GenericEventAttrs<Target> & { children?: unknown };\n\n    type HTMLAttributes<Target extends EventTarget>\n      = HTMLAttrs & DOMAttributes<Target>;\n\n    type SVGAttributes<Target extends EventTarget>\n      = SVGAttrs & HTMLAttributes<Target>;\n\n    type IntrinsicElements =\n      & { [El in keyof HTMLElements]: HTMLAttributes<HTMLElements[El]>; }\n      & { [El in keyof SVGElements]: SVGAttributes<SVGElements[El]>; };\n  }\n}\n", "import { api } from './index.js';\n\ntype Value = Node | string | number;\ntype Frag = { _startMark: Text };\ntype FragReturn = Frag | Node | undefined;\n\nconst asNode = (value: unknown): Text | Node | DocumentFragment => {\n  if (typeof value === 'string') {\n    return document.createTextNode(value);\n  }\n  // Note that a DocumentFragment is an instance of Node\n  if (!(value instanceof Node)) {\n    // Passing an empty array creates a DocumentFragment\n    // Note this means api.add is not purely a subcall of api.h; it can nest\n    return api.h([], value) as DocumentFragment;\n  }\n  return value;\n};\n\nconst maybeFragOrNode = (value: Text | Node | DocumentFragment): FragReturn => {\n  const { childNodes } = value;\n  // eslint-disable-next-line eqeqeq\n  if (value.nodeType != 11 /* DOCUMENT_FRAGMENT_NODE */) return;\n  if (childNodes.length < 2) return childNodes[0];\n  // For a fragment of 2 elements or more add a startMark. This is required for\n  // multiple nested conditional computeds that return fragments.\n\n  // It looks recursive here but the next call's fragOrNode is only Text('')\n  return { _startMark: api.add(value, '', childNodes[0]) as Text };\n};\n\n/** Add a node before a reference node or at the end. */\nconst add = (parent: Node, value: Value | Value[], endMark?: Node) => {\n  value = asNode(value);\n  const fragOrNode = maybeFragOrNode(value) || value;\n\n  // If endMark is `null`, value will be added to the end of the list.\n  parent.insertBefore(value, (endMark && endMark.parentNode && endMark) as Node | null);\n  return fragOrNode;\n};\n\nexport { add };\n", "import { api } from './index.js';\n\ntype Frag = { _startMark: Text };\n\n/** Insert a node into an existing node. */\nconst insert = (el: Node, value: unknown, endMark?: Node, current?: Node | Frag, startNode?: ChildNode | null) => {\n  // This is needed if the el is a DocumentFragment initially.\n  el = (endMark && endMark.parentNode) || el;\n\n  // Save startNode of current. In clear() endMark.previousSibling is not always\n  // accurate if content gets pulled before clearing.\n  startNode = (startNode || current instanceof Node && current) as ChildNode | null;\n\n  if (value === current) {}\n  else if (\n    (!current || typeof current === 'string')\n    // @ts-ignore Doesn't like `value += ''`\n    // eslint-disable-next-line no-implicit-coercion\n    && (typeof value === 'string' || (typeof value === 'number' && (value += '')))\n  ) {\n    // Block optimized for string insertion\n    // eslint-disable-next-line eqeqeq\n    if ((current as unknown) == null || !el.firstChild) {\n      if (endMark) {\n        api.add(el, value, endMark);\n      } else {\n        // Using textContent is a lot faster than append -> createTextNode\n        el.textContent = value as string; // Because value += ''\n      }\n    } else {\n      if (endMark) {\n        // @ts-expect-error Illegal `data` property\n        (endMark.previousSibling || el.lastChild).data = value;\n      } else {\n        // @ts-expect-error Illegal `data` property\n        el.firstChild.data = value;\n      }\n    }\n    // @ts-expect-error Reusing the variable but doesn't match the signature\n    current = value;\n  }\n  else if (\n    api.patch(value, (v) =>\n      current = api.insert(el, v, endMark, current, startNode), el)\n  ) {}\n  else {\n    // Block for Node, Fragment, Array, Functions, etc. This stringifies via h()\n    if (endMark) {\n      // `current` can't be `0`, it's coerced to a string in insert.\n      if (current) {\n        if (!startNode) {\n          // Support fragments\n          startNode = (\n            (current as { _startMark?: Text })._startMark\n              && (current as Frag)._startMark.nextSibling\n          ) || endMark.previousSibling;\n        }\n        api.rm(el, startNode, endMark);\n      }\n    } else {\n      el.textContent = '';\n    }\n    current = value && value !== true\n      ? api.add(el, value as string | number, endMark)\n      : undefined;\n  }\n  return current;\n};\n\nexport { insert };\n", "/* eslint-disable eqeqeq */\nimport { api } from './index.js';\n\ntype EventHandler = (ev: Event) => unknown;\ntype NodeEvented = Node & { $l?: { [name: string]: EventHandler } };\n\n// Note that isAttr is never set. It exists mostly to maintain API compatibility\n// with Sinuous and its community packages. However, it's also possible to wrap\n// the api.property function and set isAttr from there if needed\n\n/** Set attributes and propeties on a node. */\nexport const property = (el: Node, value: unknown, name: string | null, isAttr?: boolean, isCss?: boolean) => {\n  if (value == null) {}\n  else if (!name) {\n    for (name in value as { [k: string]: unknown }) {\n      api.property(el, (value as { [k: string]: unknown })[name], name, isAttr, isCss);\n    }\n  }\n  // Functions added as event handlers are not executed on render\n  // There's only one event listener per type\n  else if (name[0] == 'o' && name[1] == 'n') {\n    const listeners = (el as NodeEvented).$l || ((el as NodeEvented).$l = {});\n    name = name.slice(2).toLowerCase();\n    // Remove the previous function\n    if (listeners[name]) {\n      el.removeEventListener(name, listeners[name] as EventHandler); // TS bug\n      delete listeners[name];\n    }\n    el.addEventListener(name, value as EventHandler);\n    listeners[name] = value as EventHandler;\n  }\n  else if (\n    api.patch(value, (v) => api.property(el, v, name, isAttr, isCss), el, name)\n  ) {}\n  else if (isCss) {\n    (el as HTMLElement | SVGElement).style.setProperty(name, value as string);\n  }\n  else if (\n    isAttr\n    || name.slice(0, 5) == 'data-'\n    || name.slice(0, 5) == 'aria-'\n  ) {\n    (el as HTMLElement | SVGElement).setAttribute(name, value as string);\n  }\n  else if (name == 'style') {\n    if (typeof value === 'string') {\n      (el as HTMLElement | SVGElement).style.cssText = value;\n    } else {\n      api.property(el, value, null, isAttr, true);\n    }\n  }\n  else {\n    // Default case; add as a property\n    // @ts-expect-error\n    el[name == 'class' ? name + 'Name' : name] = value;\n  }\n};\n", "/** Removes nodes from `startNode` (inclusive) to `endMark` (exclusive). */\nconst remove = (parent: Node, startNode: ChildNode | null, endMark: Node) => {\n  while (startNode && startNode !== endMark) {\n    const n = startNode.nextSibling;\n    // Is needed in case the child was pulled out the parent before clearing.\n    if (parent === startNode.parentNode) {\n      parent.removeChild(startNode);\n    }\n    startNode = n;\n  }\n};\n\nexport { remove };\n", "import { api } from './index.js';\n\n/** Renders SVGs by setting h() to the SVG namespace. */\nconst svg = <T extends () => Node>(closure: T): ReturnType<T> => {\n  const prev = api.ns;\n  api.ns = 'http://www.w3.org/2000/svg';\n  const el = closure();\n  api.ns = prev;\n  return el as ReturnType<T>;\n};\n\nexport { svg };\n"],
  "mappings": "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",
  "names": []
}
