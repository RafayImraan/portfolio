{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["// Haptic is a bundle of haptic/dom configured to work with haptic/state as the\n// reactivity engine. You access haptic/state on its own:\n\n// import { h } from 'haptic';\n// import { signal, wire } from 'haptic/state';\n\n// The 'haptic' package doesn't embed haptic/state in the bundle; code is only\n// loaded once despite having two import sites. This should work well for both\n// bundlers and unbundled ESM-only/Snowpack/UNPKG workflows. It's important to\n// only run one instance of haptic/state because reactivity depends on accessing\n// some shared global state that is setup during import.\n\n// This bundle also extends the JSX namespace to allow using wires in attributes\n// and children. Use haptic/dom directly to use a vanilla JSX namespace or to\n// extend it yourself for other reactive state libraries.\n\n// Higher-level features such as control flow, lifecycles, and context are\n// available in haptic/stdlib\n\nimport { api, h, svg } from 'haptic/dom';\n\nimport type { Component, El, Tag } from 'haptic/dom';\nimport type { Wire } from 'haptic/state';\nimport type { GenericEventAttrs, HTMLAttrs, SVGAttrs, HTMLElements, SVGElements } from './jsx';\n\n// When publishing swap out api.h for the correct JSX namespace in index.d.ts\n// https://github.com/heyheyhello/haptic/commit/d7cd2819f538c3901ffb0c59e9226fa68d3ae4a9\n// declare api = Omit<typeof _api, 'h'> & { h: typeof h };\n\napi.patch = (value, patchDOM) => {\n  // I like type fields that use 1 instead of true/false, so convert via `!!`\n  // eslint-disable-next-line no-implicit-coercion\n  const $wire = (value && !!(value as Wire).$wire) as boolean;\n  if ($wire && patchDOM) {\n    (value as Wire).tasks.add(patchDOM);\n    (value as Wire)();\n  }\n  return $wire;\n};\n\nexport { api, h, svg };\nexport type { Component, El, Tag };\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype DistributeWire<T> = T extends any ? Wire<T> : never;\n\ndeclare namespace h {\n  export namespace JSX {\n    type MaybeWire<T> = T | DistributeWire<T>;\n    type AllowWireForProperties<T> = { [K in keyof T]: MaybeWire<T[K]> };\n\n    type Element = HTMLElement | SVGElement | DocumentFragment;\n\n    interface ElementAttributesProperty { props: unknown; }\n    interface ElementChildrenAttribute { children: unknown; }\n\n    // Prevent children on components that don't declare them\n    interface IntrinsicAttributes { children?: never; }\n\n    // Allow children on all DOM elements (not components, see above)\n    // ESLint will error for children on void elements like <img/>\n    type DOMAttributes<Target extends EventTarget>\n      = GenericEventAttrs<Target> & { children?: unknown };\n\n    type HTMLAttributes<Target extends EventTarget>\n      = AllowWireForProperties<Omit<HTMLAttrs, 'style'>>\n        & { style?:\n            | MaybeWire<string>\n            | { [key: string]: MaybeWire<string | number> };\n          }\n        & DOMAttributes<Target>;\n\n    type SVGAttributes<Target extends EventTarget>\n      = AllowWireForProperties<SVGAttrs> & HTMLAttributes<Target>;\n\n    type IntrinsicElements =\n      & { [El in keyof HTMLElements]: HTMLAttributes<HTMLElements[El]>; }\n      & { [El in keyof SVGElements]: SVGAttributes<SVGElements[El]>; };\n  }\n}\n"],
  "mappings": "mlBAAA,mDAmBA,MAA4B,yBAU5B,MAAI,MAAQ,CAAC,EAAO,IAAa,CAG/B,GAAM,GAAS,GAAS,CAAC,CAAE,EAAe,MAC1C,MAAI,IAAS,GACV,GAAe,MAAM,IAAI,GACzB,KAEI",
  "names": []
}
